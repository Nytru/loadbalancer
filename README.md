# Ответы на вопросы
1. Опишите самую интересную задачу в программировании, которую вам приходилось решать?
2. Расскажите о своем самом большом факапе? Что вы предприняли для решения проблемы?
3. Каковы ваши ожидания от участия в буткемпе?

- Самая интересная задача - создание сервиса контроля пользовательских лимитов. Задача включала в себя проектирование и разработку нескольких микросервисов и интеграцию их в пайплайн обработки запросов. Больше всего понравилась возможность спроектировать решение, которое максимально подходит в требуемой ситуации, возможность увидеть своей работы в лице благодарных команд.

- Самый большой факап - отсутствие мониторинга за диском mongodb кластера привело к тому, что выполнение тяжелого скрипта переполнило память и кластер упал. Пришлось восстанавливать из бэкапа. После того случая, я более ответственно подхожу к мониторингу и логированию, а так же анализу потенциальныз проблем разработки, тестирования и всей затрагиваемой области.

- Ожидания от буткемпа - это погружение в реальные задачи, возможность разрабатывать высоконагруженные системы. Получить возможность дальнейшего роста и развития в компании и реализации себя как специалиста.


# Reverce-proxy сервер и Ratelimiter

Первый запуск сервиса: `docker compose up postgres redis -d` (первая инициализация базы данных может быть долгой)  

Запуск сервиса: `docker compose up -d`

Путь к конфигурационному файлу необходимо указать через аргументы запуска программы (в docker-compose.yaml это сделано по умолчанию):
`--configuration path/to/file/file.yaml`

Пример конфигурации:  

``` yaml
proxy_listen: "0.0.0.0:8080"
admin_listen: "0.0.0.0:80"

loadbalancer:
  backends:
    - name: backend1
      url: http://backend1:5678
    - name: backend2
      url: http://backend2:5678
    - name: backend3
      url: http://backend3:5678
  health_check:
    timeout: 3s
    interval: 10s
    health_url: /health

rate_limit:
  capacity: 10
  refill_interval: 10s
  enabled: true

postgres_database:
  host: postgres
  port: 5432
  user: postgres
  password: postgres
  dbname: postgres

  migrations_path: /app/migrations

# log_path: ../logs.log # Путь к файлу для логов. Отсутсвие - вывод в консоль

redis_database:
  addr: redis:6379
  password: redis
  db: 0
```

Сервер запускается для обслуживания 2х роутов:  
`proxy_listen` - адрес запросы с которого проксируются на бэкенды  
`admin_listen` - адрес запросы на который предназначены для сохранения настраеваемых лимитов пользователя

## Ключевые особенности

Настройка конфигурации:

- Конфигурация сервиса хранится в yaml файле

Поддержка нескольких алгоритмов распределения и лимитирования:  

- Ratelimiter и reverce-proxy интегрированы в систему через интерфейсы

CRUD для управления клиентами:  

- Реализован CRUD для управления клиентами и их лимитами

Персистентность:  

- Использование Redis (с настройками персистентности) для хранения состояния лимитов и Postgres для хранения настроек пользователей позволяет легко управлять состоянием системы и восстанавливать его после перезапуска.


## Запросы для изменения лимитов пользователей (admin_listen routes)  

`0.0.0.0:80/clients?id=user_id - GET`  

### user_id - id пользователя, строчка

---

`0.0.0.0:80/clients - POST`  

### Body:  
``` json
{
    "id" : "192.168.97.11",
    "capacity" : 20,
    "refill_interval_ms": 500
}
```

---

`0.0.0.0:80/clients - PUT`

### Body:  
``` json
{
    "id" : "192.168.97.11",
    "capacity" : 20,
    "refill_interval_ms": 500
}
```

---

`0.0.0.0:80/clients?id=user_id - DELTE`  

### user_id - id пользователя, строчка

## Сервис бэкендов и прокси (round-robin)

#### В качестве идентификатора пользователя используется ip адрес клиента, который делает запрос к прокси серверу.  

Алгоритм инициализации reverse proxy сервера:
1. Получаем конфигурацию из файла
2. Сохраняем в память список бэкендов
3. Для всех бэкендов запускаем горутину, которая проверяет их состояние (health check)
    - Если бэкенд не доступен, то помечаем его как недоступный (если в следующий раз он ответит успешно, то помечаем его как доступный)


Алгоритм reverse proxy сервера:
1. Получаем запрос от клиента
2. Получаем список доступных
3. Проксируем запрос на один из доступных бэкендов
    - Если бэкенд доступен, то возвращаем ответ от него
    - Если бэкенд недоступен, то возвращаем ошибку 502 (Bad Gateway)
    - Если все бэкенды недоступны, то возвращаем ошибку 503 (Bad Gateway)

## Сервис лимитов (bucket rate limiter)

Алгоритм инициализации сервиса лимитов:
1. Получаем конфигурацию из файла
2. Инициализируем im-memory хранилище
    - из сохраненных лимитов в Redis восстанавливаем состояние лимитов
    - из настроеных правил пользователей в Postgres восстанавливаем состояние настроеных правил
3. Про создании очередного bucket'а запускаем горутину, которая пополняет его один раз в `refill_interval` (по умолчанию 10 секунд)
    - Если у пользователя есть личное правило (личный лимит), то используем его

Алгоритм работы сервиса лимитов:
1. Получаем запрос от клиента
2. Получаем ip адрес клиента (id)
3. Получаем bucket для пользователя из и настройки личных лимитов in-memory хранилища
    - Если bucket существует, то ипользуем bucket и его настройки лимитов
    - Если bucket не существует, и личное правило не настроено, то используем настройки по умолчанию
    - Если bucket не существует, и личное правило настроено, то создаем новый bucket с личными настройками  


## Интеграционные тесты

Для запуска интеграционных тестов необходимо запустить сервисы: `docker compose up -d`
Перейти в папку с тестами: `cd tests`

Для тестирования логики добавления лимитов пользователей необходимо запустить тесты:  
`go test ./clients_test.go`

Для тестирования логики работы с бэкендами необходимо запустить тесты:  
`go test ./proxy/proxy_test.go`  
`go test -bench=. -benchtime=10s -v -race ./proxy/benchmarks_proxy_test.go`  

Для тестирования логики работы с лимитами необходимо запустить тесты:

Необходимо убедится что ratelimiter включен в конфигурации:  
``` yaml
rate_limit:
  enabled: true
```

Перезагрузить сервис: `docker compose restart r-proxy`

`go test ./ratelimiter/ratelimiter_test.go`  
`go test -bench=. -benchtime=10s -v -race ./proxy/benchmarks_proxy_test.go`  
